;;speed optimized CRC computation for constant polynom:
;;
;;typedef unsigned char u8;
;;typedef unsigned short u16;
;;
;;u16 crcu8 (u8 data, u16 crc)
;;{
;;  crc ^= data;
;;  return (crc >> 8) ^ crc_tab[crc & 0xff];
;;}
;;
;;using table generated by:
;;
;;#include <stdio.h>
;;#include <stdlib.h>
;;
;;int main (void)
;;{
;;  unsigned polynom = 0xa001;
;;  printf ("static const u16 crc_tab[] =\n  { ");
;;  for (int i = 0; i < 256; i++)
;;    {
;;      unsigned crc = i;
;;      for (int j = 0; j < 8; j++)
;;        {
;;          int tmp = crc & 1;
;;          crc >>= 1;
;;          if (tmp)
;;            crc ^= pol;
;;        }
;;      printf ("0x%04x", crc);
;;      if (i % 8 != 7)
;;        printf (", ");
;;      else if (i < 255)
;;        printf (",\n    ");
;;    }
;;  printf ("\n  };\n");
;;  exit (0);
;;}

;;Lower code size implementation, and for variable polynoms.
;;Gets unrolled if not optimizing for size, but still compact.
;;
;;static
;;u16 crcu16_1(u16 data, u16 crc, u16 xor_val)
;;{
;;  unsigned long tmp = data ^ crc;
;;  if (!tmp)
;;    return tmp;
;;  for (int i = 0; i < 16; i++)
;;    {
;;#if 1 /* Using ROR.  */
;;      tmp = (tmp >> 1) | (tmp << (sizeof (tmp) * (8 /*CHAR_BIT*/) - 1));
;;      if ((long)tmp < 0)
;;#else /* For base instruction set.  */
;;      long tmp2 = tmp & 1;
;;      tmp >>= 1;
;;      if (tmp2)
;;#endif
;;        tmp ^= xor_val;
;;    }
;;  return tmp;
;;}
;;
;;u16 crcu16 (u16 data, u16 crc)
;;{
;;  u16 xor_val;
;;#if 0
;;  xor_val = 0xa001;
;;#else /* Avoid unwanted constant propagation.  */
;;  asm ("" : "=r" (xor_val) : "0" (0xa001));
;;#endif
;;  return crcu16_1 (data, crc, xor_val);
;;}


(define_expand "riscv_crc16b"
  [(pc)]
)

(define_expand "riscv_crc16h"
  [(pc)]
)
